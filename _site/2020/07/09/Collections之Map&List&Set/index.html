<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>并发编程(九)-Collections之Map&List&Set详解 &mdash; 文浩</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/primer-markdown/dist/user-content.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="http://localhost:4000/2020/07/09/Collections%E4%B9%8BMap&List&Set/"><link rel="alternate" type="application/atom+xml" title="文浩" href="http://localhost:4000/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/favicon.ico"><meta property="og:title" content="并发编程(九)-Collections之Map&List&Set详解"><meta name="keywords" content="wenhao , 文浩 , 似水似流年 , wenhaoclub , fuwenhao.club , 文浩的博客"><meta name="og:keywords" content="wenhao , 文浩 , 似水似流年 , wenhaoclub , fuwenhao.club , 文浩的博客"><meta name="description" content="HashMap"><meta name="og:description" content="HashMap"><meta property="og:url" content="http://localhost:4000/2020/07/09/Collections%E4%B9%8BMap&List&Set/"><meta property="og:site_name" content="文浩"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-07-09"> <script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,"script","https://cdn.jsdelivr.net/gh/wenhaoclub/blog-assets/files/js/84f024a1.js","daovoice"); daovoice('init', { app_id: "84f024a1" }); daovoice('update'); </script> <script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="http://localhost:4000/" title="文浩"><span class="octicon octicon-mark-github"></span> 文浩</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="http://localhost:4000/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="http://localhost:4000/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="http://localhost:4000/archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="http://localhost:4000/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="http://localhost:4000/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="http://localhost:4000/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="并发编程(九)-Collect"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">并发编程(九)-Collections之Map&List&Set详解</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/07/09 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="http://localhost:4000/categories/#并发" title="并发">并发</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 10158 字，约 30 分钟 </span></div></div></div><div class="column one-fourths mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><div><article class="article-content markdown-body"><h1 id="hashmap">HashMap</h1><h2 id="数据结构">数据结构</h2><p>数组+链表+(红黑树jdk&gt;=8)</p><h2 id="源码原理分析">源码原理分析</h2><p>重要成员变量 DEFAULT_INITIAL_CAPACITY = 1 « 4; Hash表默认初始容量 MAXIMUM_CAPACITY = 1 « 30; 最大Hash表容量 DEFAULT_LOAD_FACTOR = 0.75f；默认加载因子 TREEIFY_THRESHOLD = 8；链表转红黑树阈值 UNTREEIFY_THRESHOLD = 6；红黑树转链表阈值 MIN_TREEIFY_CAPACITY = 64；链表转红黑树时hash表最小容量阈值，达不到优先扩容。 内部的执行机制源码 见课堂讲解。 HashMap是线程不安全的，不安全的具体原因就是在高并发场景下，扩容可能产生死锁(Jdk1.7存在)以及get操作可能带来的数据丢失。</p><h2 id="jdk7-扩容死锁分析">Jdk7-扩容死锁分析</h2><p>死锁问题核心在于下面代码，多线程扩容导致形成的链表环!</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">transfer</span><span class="o">(</span><span class="n">Entry</span><span class="o">[]</span> <span class="n">newTable</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">rehash</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">newCapacity</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">:</span> <span class="n">table</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span><span class="c1">//第一行</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">rehash</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span> <span class="kc">null</span> <span class="o">==</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">hash</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">indexFor</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span><span class="o">,</span> <span class="n">newCapacity</span><span class="o">);</span><span class="c1">//第二行</span>
            <span class="n">e</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">[</span><span class="n">i</span><span class="o">];</span><span class="c1">//第三行</span>
            <span class="n">newTable</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span><span class="c1">//第四行</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span><span class="c1">//第五行</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>去掉了一些冗余的代码， 层次结构更加清晰了。 第一行：记录oldhash表中e.next 第二行：rehash计算出数组的位置(hash表中桶的位置) 第三行：e要插入链表的头部， 所以要先将e.next指向new hash表中的第一个元素 第四行：将e放入到new hash表的头部 第五行： 转移e到下一个节点， 继续循环下去</p><h3 id="单线程扩容">单线程扩容</h3><p>假设：hash算法就是简单的key与length(数组长度)求余。hash表长度为2，如果不扩容， 那么元素key为3,5,7按照计算(key%table.length)的话都应该碰撞到table[1]上。 扩容：hash表长度会扩容为4重新hash，key=3 会落到table[3]上(3%4=3)， 当前e.next为key(7), 继续while循环重新hash，key=7 会落到table[3]上(7%4=3), 产生碰撞， 这里采用的是头插入法，所以key=7的Entry会排在key=3前面(这里可以具体看while语句中代码)当前e.next为key(5), 继续while循环重新hash，key=5 会落到table[1]上(5%4=3)， 当前e.next为null, 跳出while循环，resize结束。 如下图所示</p><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210721200805156.png" alt="image-20210721200805156" style="zoom:50%;" /></p><h3 id="多线程扩容">多线程扩容</h3><p>下面就是多线程同时put的情况了， 然后同时进入transfer方法中：假设这里有两个线程同时执行了put()操作，并进入了transfer()环节</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="o">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span><span class="c1">//第一行，线程1执行到此被调度挂起</span>
      <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">indexFor</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span><span class="o">,</span> <span class="n">newCapacity</span><span class="o">);</span><span class="c1">//第二行</span>
      <span class="n">e</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">[</span><span class="n">i</span><span class="o">];</span><span class="c1">//第三行</span>
      <span class="n">newTable</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span><span class="c1">//第四行</span>
      <span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span><span class="c1">//第五行</span>
<span class="o">}</span>
</code></pre></div></div><p>那么此时状态为：</p><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210721200840587.png" alt="image-20210721200840587" style="zoom:50%;" /></p><p>从上面的图我们可以看到，因为线程1的 e 指向了 key(3)，而 next 指向了 key(7)，在线程2 rehash 后，就指向了线程2 rehash 后的链表。 然后线程1被唤醒了： 执行e.next = newTable[i]，于是 key(3)的 next 指向了线程1的新 Hash 表，因为新 Hash 表为空，所以e.next = null， 执行newTable[i] = e，所以线程1的新 Hash 表第一个元素指向了线程2新 Hash 表的 key(3)。好了，e 处理完毕。 执行e = next，将 e 指向 next，所以新的 e 是 key(7) 然后该执行 key(3)的 next 节点 key(7)了: 现在的 e 节点是 key(7)，首先执行Entry&lt;K,V&gt; next = e.next,那么 next 就是 key(3)了 执行e.next = newTable[i]，于是key(7) 的 next 就成了 key(3) 执行newTable[i] = e，那么线程1的新 Hash 表第一个元素变成了 key(7) 执行e = next，将 e 指向 next，所以新的 e 是 key(3) 此时状态为：</p><p>然后又该执行 key(7)的 next 节点 key(3)了： 现在的 e 节点是 key(3)，首先执行Entry&lt;K,V&gt; next = e.next,那么 next 就是 null 执行e.next = newTable[i]，于是key(3) 的 next 就成了 key(7) 执行newTable[i] = e，那么线程1的新 Hash 表第一个元素变成了 key(3) 执行e = next，将 e 指向 next，所以新的 e 是 key(7) 这时候的状态如图所示：</p><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210721200914266.png" alt="image-20210721200914266" style="zoom:50%;" /></p><p>很明显，环形链表出现了。</p><h2 id="jdk8-扩容">Jdk8-扩容</h2><p>Java8 HashMap扩容跳过了Jdk7扩容的坑，对源码进行了优化，采用高低位拆分转移方式，避免了链表环的产生。 扩容前：</p><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210721200937044.png" alt="image-20210721200937044" style="zoom:50%;" /></p><p>扩容后：</p><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210721201000038.png" alt="image-20210721201000038" style="zoom:50%;" /></p><p>由于Jdk8引入了新的数据结构，所以put方法过程也有了一定改进，其过程如下图所示。</p><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210721201021553.png" alt="image-20210721201021553" style="zoom:50%;" /></p><h1 id="concurrenthashmap">ConcurrentHashMap</h1><h2 id="数据结构-1">数据结构</h2><p>ConcurrentHashMap的数据结构与HashMap基本类似，区别在于：1、内部在数据写入时加了同步机制(分段锁)保证线程安全，读操作是无锁操作；2、扩容时老数据的转移是并发执行的，这样扩容的效率更高。</p><h2 id="并发安全控制">并发安全控制</h2><p>Java7 ConcurrentHashMap基于ReentrantLock实现分段锁</p><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210721201057376.png" alt="image-20210721201057376" style="zoom:50%;" /></p><p>Java8中 ConcurrentHashMap基于分段锁+CAS保证线程安全，分段锁基于synchronized关键字实现；</p><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210721201130480.png" alt="image-20210721201130480" style="zoom:50%;" /></p><h2 id="源码原理分析-1">源码原理分析</h2><h3 id="重要成员变量">重要成员变量</h3><p>ConcurrentHashMap拥有出色的性能, 在真正掌握内部结构时, 先要掌握比较重要的成员: LOAD_FACTOR: 负载因子, 默认75%, 当table使用率达到75%时, 为减少table的hash碰撞, tabel长度将扩容一倍。负载因子计算: 元素总个数%table.lengh TREEIFY_THRESHOLD: 默认8, 当链表长度达到8时, 将结构转变为红黑树。 UNTREEIFY_THRESHOLD: 默认6, 红黑树转变为链表的阈值。 MIN_TRANSFER_STRIDE: 默认16, table扩容时, 每个线程最少迁移table的槽位个数。 MOVED: 值为-1, 当Node.hash为MOVED时, 代表着table正在扩容 TREEBIN, 置为-2, 代表此元素后接红黑树。 nextTable: table迁移过程临时变量, 在迁移过程中将元素全部迁移到nextTable上。 sizeCtl: 用来标志table初始化和扩容的,不同的取值代表着不同的含义: 0: table还没有被初始化 -1: table正在初始化 小于-1: 实际值为resizeStamp(n)«RESIZE_STAMP_SHIFT+2, 表明table正在扩容 大于0: 初始化完成后, 代表table最大存放元素的个数, 默认为0.75*n transferIndex: table容量从n扩到2n时, 是从索引n-&gt;1的元素开始迁移, transferIndex代表当前已经迁移的元素下标 ForwardingNode: 一个特殊的Node节点, 其hashcode=MOVED, 代表着此时table正在做扩容操作。扩容期间, 若table某个元素为null, 那么该元素设置为ForwardingNode, 当下个线程向这个元素插入数据时, 检查hashcode=MOVED, 就会帮着扩容。 ConcurrentHashMap由三部分构成, table+链表+红黑树, 其中table是一个数组, 既然是数组, 必须要在使用时确定数组的大小, 当table存放的元素过多时, 就需要扩容, 以减少碰撞发生次数, 本文就讲解扩容的过程。扩容检查主要发生在插入元素(putVal())的过程: 一个线程插完元素后, 检查table使用率, 若超过阈值, 调用transfer进行扩容 一个线程插入数据时, 发现table对应元素的hash=MOVED, 那么调用helpTransfer()协助扩容。</p><h3 id="协助扩容helptransfer">协助扩容helpTransfer</h3><p>下面是协助扩容的过程</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="nf">helpTransfer</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//table扩容</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">nextTab</span><span class="o">;</span> <span class="kt">int</span> <span class="n">sc</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">f</span> <span class="k">instanceof</span> <span class="n">ForwardingNode</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
            <span class="o">(</span><span class="n">nextTab</span> <span class="o">=</span> <span class="o">((</span><span class="n">ForwardingNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">f</span><span class="o">).</span><span class="na">nextTable</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 根据 length 得到一个标识符号</span>
            <span class="kt">int</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">resizeStamp</span><span class="o">(</span><span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">nextTab</span> <span class="o">==</span> <span class="n">nextTable</span> <span class="o">&amp;&amp;</span> <span class="n">table</span> <span class="o">==</span> <span class="n">tab</span> <span class="o">&amp;&amp;</span>
                   <span class="o">(</span><span class="n">sc</span> <span class="o">=</span> <span class="n">sizeCtl</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span><span class="c1">//说明还在扩容</span>
                <span class="c1">//判断是否标志发生了变化||  扩容结束了</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">sc</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">RESIZE_STAMP_SHIFT</span><span class="o">)</span> <span class="o">!=</span> <span class="n">rs</span> <span class="o">||</span> <span class="n">sc</span> <span class="o">==</span> <span class="n">rs</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">||</span>
                     <span class="c1">//达到最大的帮助线程 ||  判断扩容转移下标是否在调整（扩容结束）</span>
                    <span class="n">sc</span> <span class="o">==</span> <span class="n">rs</span> <span class="o">+</span> <span class="n">MAX_RESIZERS</span> <span class="o">||</span> <span class="n">transferIndex</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="c1">// 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">SIZECTL</span><span class="o">,</span> <span class="n">sc</span><span class="o">,</span> <span class="n">sc</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">transfer</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">nextTab</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">nextTab</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">table</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>主要做了如下事情: 检查是否扩容完成 对sizeCtrl = sizeCtrl+1, 然后调用transfer()进行真正的扩容。</p><h3 id="扩容transfer">扩容transfer</h3><p>扩容的整体步骤就是新建一个nextTab, size是之前的2倍, 将table上的非空元素迁移到nextTab上面去。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">transfer</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">nextTab</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">stride</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">stride</span> <span class="o">=</span> <span class="o">(</span><span class="n">NCPU</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">?</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">3</span><span class="o">)</span> <span class="o">/</span> <span class="n">NCPU</span> <span class="o">:</span> <span class="n">n</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">MIN_TRANSFER_STRIDE</span><span class="o">)</span>
       <span class="c1">// subdivide range，每个线程最少迁移16个槽位，大的话，最多</span>
        <span class="n">stride</span> <span class="o">=</span> <span class="n">MIN_TRANSFER_STRIDE</span><span class="o">;</span>
    <span class="c1">// initiating  才开始初始化新的nextTab</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nextTab</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
            <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">nt</span> <span class="o">=</span> <span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="n">Node</span><span class="o">&lt;?,?&gt;[</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">];</span>  <span class="c1">//扩容2倍</span>
            <span class="n">nextTab</span> <span class="o">=</span> <span class="n">nt</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>      <span class="c1">// try to cope with OOME</span>
            <span class="n">sizeCtl</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">nextTable</span> <span class="o">=</span> <span class="n">nextTab</span><span class="o">;</span>
        <span class="n">transferIndex</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span><span class="c1">//更新的转移下标，</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">nextn</span> <span class="o">=</span> <span class="n">nextTab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="n">ForwardingNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">fwd</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ForwardingNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;(</span><span class="n">nextTab</span><span class="o">);</span>
    <span class="c1">//是否能够向前推进到下一个周期</span>
    <span class="kt">boolean</span> <span class="n">advance</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="c1">// to ensure sweep before committing nextTab，完成状态，如果是，则结束此方法</span>
    <span class="kt">boolean</span> <span class="n">finishing</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bound</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;;)</span> <span class="o">{</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">;</span> <span class="kt">int</span> <span class="n">fh</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">advance</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//取下一个周期</span>
            <span class="kt">int</span> <span class="n">nextIndex</span><span class="o">,</span> <span class="n">nextBound</span><span class="o">;</span>
            <span class="c1">//本线程处理的区间范围为[bound, i),范围还没有处理完成，那么就继续处理</span>
            <span class="k">if</span> <span class="o">(--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">bound</span> <span class="o">||</span> <span class="n">finishing</span><span class="o">)</span>
                <span class="n">advance</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="c1">//目前处理到了这里（从大到小， 下线），开始找新的一轮的区间</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">nextIndex</span> <span class="o">=</span> <span class="n">transferIndex</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="n">advance</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//这个条件改变的是transferIndex的值，从16变成了1</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapInt</span>
                     <span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">TRANSFERINDEX</span><span class="o">,</span> <span class="n">nextIndex</span><span class="o">,</span>
                     <span class="c1">//nextBound 是这次迁移任务的边界，注意，是从后往前</span>
                      <span class="n">nextBound</span> <span class="o">=</span> <span class="o">(</span><span class="n">nextIndex</span> <span class="o">&gt;</span> <span class="n">stride</span> <span class="o">?</span>
                                   <span class="n">nextIndex</span> <span class="o">-</span> <span class="n">stride</span> <span class="o">:</span> <span class="mi">0</span><span class="o">)))</span> <span class="o">{</span>
                <span class="n">bound</span> <span class="o">=</span> <span class="n">nextBound</span><span class="o">;</span> <span class="c1">//一块区间最小桶的下标</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">nextIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">//能够处理的最大桶的下标</span>
                <span class="n">advance</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">nextn</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//每个迁移线程都能达到这里</span>
            <span class="kt">int</span> <span class="n">sc</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">finishing</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//迁移完成</span>
                <span class="n">nextTable</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="c1">//直接把以前的table丢弃了，上面的MOVE等标志全部丢弃，使用新的</span>
                <span class="n">table</span> <span class="o">=</span> <span class="n">nextTab</span><span class="o">;</span>
                <span class="n">sizeCtl</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">//扩大2n-0.5n = 1.50n, 更新新的容量阈值</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//表示当前线程迁移完成了</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">SIZECTL</span><span class="o">,</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">sizeCtl</span><span class="o">,</span> <span class="n">sc</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
                 <span class="c1">//注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">sc</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">!=</span> <span class="n">resizeStamp</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="n">RESIZE_STAMP_SHIFT</span><span class="o">)</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="n">finishing</span> <span class="o">=</span> <span class="n">advance</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span> <span class="c1">// recheck before commit</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//如果对应位置为null， 则将ForwardingNode放在对应的地方</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">f</span> <span class="o">=</span> <span class="n">tabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">advance</span> <span class="o">=</span> <span class="n">casTabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">fwd</span><span class="o">);</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">fh</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">hash</span><span class="o">)</span> <span class="o">==</span> <span class="n">MOVED</span><span class="o">)</span> <span class="c1">//别的线程已经在处理了，再推进一个下标</span>
            <span class="n">advance</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// already processed，推动到下一个周期，仍然会检查i与bound是否结束</span>
        <span class="k">else</span> <span class="o">{</span> <span class="c1">//说明位置上有值了，</span>
            <span class="c1">//需要加锁，防止再向里面放值，在放数据时，也会锁住。比如整个table正在迁移，还没有迁移到这个元素，另外一个线程向这个节点插入数据，此时迁移到这里了，会被阻塞住</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">tabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span><span class="c1">//判断i下标和f是否相同</span>
                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">ln</span><span class="o">,</span> <span class="n">hn</span><span class="o">;</span> <span class="c1">//高位桶， 地位桶</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">fh</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="kt">int</span> <span class="n">runBit</span> <span class="o">=</span> <span class="n">fh</span> <span class="o">&amp;</span> <span class="n">n</span><span class="o">;</span><span class="c1">//n为2^n, 取余后只能是2^n</span>
                        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">lastRun</span> <span class="o">=</span> <span class="n">f</span><span class="o">;</span>
                        <span class="c1">///找到最后一个不和fn相同的节点</span>
                        <span class="k">for</span> <span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
                            <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">n</span><span class="o">;</span>
                            <span class="c1">//只要找到这，之后的取值都是一样的，下次循环时，就不用再循环后面的</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">runBit</span><span class="o">)</span> <span class="o">{</span>
                                <span class="n">runBit</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
                                <span class="n">lastRun</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">runBit</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">ln</span> <span class="o">=</span> <span class="n">lastRun</span><span class="o">;</span>
                            <span class="n">hn</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="k">else</span> <span class="o">{</span> <span class="c1">//比如1，16，32,如果低位%16，那么肯定是0。</span>
                            <span class="n">hn</span> <span class="o">=</span> <span class="n">lastRun</span><span class="o">;</span>
                            <span class="n">ln</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="k">for</span> <span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">f</span><span class="o">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">lastRun</span><span class="o">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
                            <span class="kt">int</span> <span class="n">ph</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">hash</span><span class="o">;</span> <span class="n">K</span> <span class="n">pk</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">;</span> <span class="n">V</span> <span class="n">pv</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
                            <span class="k">if</span> <span class="o">((</span><span class="n">ph</span> <span class="o">&amp;</span> <span class="n">n</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                                 <span class="c1">//这样就把相同串的给串起来了</span>
                                <span class="n">ln</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;(</span><span class="n">ph</span><span class="o">,</span> <span class="n">pk</span><span class="o">,</span> <span class="n">pv</span><span class="o">,</span> <span class="n">ln</span><span class="o">);</span>
                            <span class="k">else</span>
                                <span class="c1">//这样就把相同串的给串起来了，注意这里ln用法，第一个next为null，烦着串起来了。</span>
                                <span class="n">hn</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;(</span><span class="n">ph</span><span class="o">,</span> <span class="n">pk</span><span class="o">,</span> <span class="n">pv</span><span class="o">,</span> <span class="n">hn</span><span class="o">);</span>
                        <span class="o">}</span>
                        <span class="n">setTabAt</span><span class="o">(</span><span class="n">nextTab</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">ln</span><span class="o">);</span> <span class="c1">//反着给串起来了</span>
                        <span class="n">setTabAt</span><span class="o">(</span><span class="n">nextTab</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="o">,</span> <span class="n">hn</span><span class="o">);</span>
                        <span class="n">setTabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">fwd</span><span class="o">);</span>
                        <span class="n">advance</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">f</span> <span class="k">instanceof</span> <span class="n">TreeBin</span><span class="o">)</span> <span class="o">{</span><span class="c1">// 如果是红黑树</span>
                        <span class="n">TreeBin</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="n">TreeBin</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">f</span><span class="o">;</span>
                        <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">lo</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">loTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">//也是高低节点</span>
                        <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">hi</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">hiTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span><span class="c1">//也是高低节点</span>
                        <span class="kt">int</span> <span class="n">lc</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">hc</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="k">for</span> <span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">first</span><span class="o">;</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//中序遍历红黑树</span>
                            <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">hash</span><span class="o">;</span>
                            <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span>
                                <span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                            <span class="k">if</span> <span class="o">((</span><span class="n">h</span> <span class="o">&amp;</span> <span class="n">n</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//0的放低位</span>
                                <span class="c1">//注意这里p.prev = loTail，每一个p都是下一个的prev</span>
                                <span class="k">if</span> <span class="o">((</span><span class="n">p</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">loTail</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                                    <span class="n">lo</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="c1">//把头记住</span>
                                <span class="k">else</span>
                                    <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>  <span class="c1">//上一次的p的next是这次的p</span>
                                <span class="n">loTail</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="c1">//把上次p给记住</span>
                                <span class="o">++</span><span class="n">lc</span><span class="o">;</span>
                            <span class="o">}</span>
                            <span class="k">else</span> <span class="o">{</span> <span class="c1">//高位</span>
                                <span class="k">if</span> <span class="o">((</span><span class="n">p</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">hiTail</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                                    <span class="n">hi</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="c1">//把尾记住</span>
                                <span class="k">else</span>
                                    <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                                <span class="n">hiTail</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                                <span class="o">++</span><span class="n">hc</span><span class="o">;</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                        <span class="n">ln</span> <span class="o">=</span> <span class="o">(</span><span class="n">lc</span> <span class="o">&lt;=</span> <span class="n">UNTREEIFY_THRESHOLD</span><span class="o">)</span> <span class="o">?</span> <span class="n">untreeify</span><span class="o">(</span><span class="n">lo</span><span class="o">)</span> <span class="o">:</span><span class="c1">// //判断是否需要转化为树</span>
                            <span class="o">(</span><span class="n">hc</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="k">new</span> <span class="n">TreeBin</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;(</span><span class="n">lo</span><span class="o">)</span> <span class="o">:</span> <span class="n">t</span><span class="o">;</span> <span class="c1">//如果没有高低的话，则部分为两个树</span>
                        <span class="n">hn</span> <span class="o">=</span> <span class="o">(</span><span class="n">hc</span> <span class="o">&lt;=</span> <span class="n">UNTREEIFY_THRESHOLD</span><span class="o">)</span> <span class="o">?</span> <span class="n">untreeify</span><span class="o">(</span><span class="n">hi</span><span class="o">)</span> <span class="o">:</span>
                            <span class="o">(</span><span class="n">lc</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="k">new</span> <span class="n">TreeBin</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;(</span><span class="n">hi</span><span class="o">)</span> <span class="o">:</span> <span class="n">t</span><span class="o">;</span>
                        <span class="n">setTabAt</span><span class="o">(</span><span class="n">nextTab</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">ln</span><span class="o">);</span>
                        <span class="n">setTabAt</span><span class="o">(</span><span class="n">nextTab</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="o">,</span> <span class="n">hn</span><span class="o">);</span>
                        <span class="n">setTabAt</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">fwd</span><span class="o">);</span>
                        <span class="n">advance</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>其中有两个变量需要了解下: advance: 表示是否可以向下一个轮元素进行迁移。 finishing: table所有元素是否迁移完成。</p><p><strong>大致做了如下事情:</strong> 确定线程每轮迁移元素的个数stride, 比如进来一个线程, 确定扩容table下标为(a,b]之间元素, 下一个线程扩容(b,c]。这里对b-a或者c-b也是由最小值16限制的。 也就是说每个线程最少扩容连续16个table的元素。而标志当前迁移的下标保存在transferIndex里面。 检查nextTab是否完成初始化, 若没有的话, 说明是第一个迁移的线程, 先初始化nextTab, size是之前table的2倍。 进入while循环查找本轮迁移的table下标元素区间, 保存在(bound, i]中, 注意这里是半开半闭区间。 从i -&gt; bound开始遍历table中每个元素, 这里是从大到小遍历的: 若该元素为空, 则向该元素标写入ForwardingNode, 然后检查下一个元素。 当别的线程向这个元素插入数据时, 根据这个标志符知道了table正在被别的线程迁移, 在putVal中就会调用helpTransfer帮着迁移。 若该元素的hash=MOVED, 代表次table正在处于迁移之中, 跳过。 按道理不会跑着这里的。 否则说明该元素跟着的是一个链表或者是个红黑树结构, 若hash&gt;0, 则说明是个链表, 若f instanceof TreeBin, 则说明是个红黑树结构。 链表迁移原理如下: 遍历链表每个节点。 若节点的f.hash&amp;n==0成立, 则将节点放在i, 否则, 则将节点放在n+i上面。 迁移前, 对该元素进行加锁。 遍历链表时, 这里使用lastRun变量, 保留的是上次hash的值, 假如整个链表全部节点f.hash&amp;n==0, 那么第二次遍历, 只要找到lastRun的值, 那么认为之后的节点都是相同值, 减少了不必要的f.hash&amp;n取值。遍历完所有的节点后, 此时形成了两条链表, ln存放的是f.hash&amp;n=0的节点, hn存放的是非0的节点, 然后将ln存放在nextTable第i元素的位置, n+i存放在n+i的位置。 蓝色节点代表:f.hash&amp;n==0, 绿色节点代表f.hash&amp;n!=0。 最终蓝色的节点仍在存放在(0, n)范围里, 绿的节点存放在(n, 2n-1)的范围之内。 迁移链表和红黑树的原理是一样的, 在红黑树中, 我们记录了每个红黑树的first(这个节点不是hash最小的节点)和每个节点的next, 根据这两个元素, 我们可以访问红黑树所有的元素, 红黑树此时也是一个链表, 红黑树和链表迁移的过程一样。红黑树根据迁移后拆分成了hn和ln, 根据链表长度确定链表是红黑树结构还是退化为了链表。 4.如何确定table所有元素迁移完成:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//表示当前线程迁移完成了</span>
<span class="k">if</span> <span class="o">(</span><span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">SIZECTL</span><span class="o">,</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">sizeCtl</span><span class="o">,</span> <span class="n">sc</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
     <span class="c1">//注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">sc</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">!=</span> <span class="n">resizeStamp</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="n">RESIZE_STAMP_SHIFT</span><span class="o">)</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="n">finishing</span> <span class="o">=</span> <span class="n">advance</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span> <span class="c1">// recheck before commit</span>
<span class="o">}</span>
</code></pre></div></div><p>第一个线程开始迁移时, 设置了sizeCtl= resizeStamp(n) « RESIZE_STAMP_SHIFT+2, 此后每个新来帮助迁移的线程都会sizeCtl=sizeCtl+1, 完成迁移后,sizeCtl-1, 那么只要有一个线程还处于迁移状态, 那么sizeCtl&gt; resizeStamp(n) « RESIZE_STAMP_SHIFT+2一直成立, 当只有最后一个线程完成迁移之后, 等式两边才成立。 可能大家会有疑问, 第一个线程并没有对sizeCtl=sizeCtl+1, 此时完成后再减一, 那不是不相等了吗, 注意这里, sizeCtl在减一前, 将值赋给了sc, 等式比较的是sc。 总结 ——————————————————————————– table扩容过程就是将table元素迁移到新的table上, 在元素迁移时, 可以并发完成, 加快了迁移速度, 同时不至于阻塞线程。所有元素迁移完成后, 旧的table直接丢失, 直接使用新的table。</p><h1 id="copyonwrite机制">CopyOnWrite机制</h1><p>核心思想：读写分离，空间换时间，避免为保证并发安全导致的激烈的锁竞争。 划关键点： 1、CopyOnWrite适用于读多写少的情况，最大程度的提高读的效率； 2、CopyOnWrite是最终一致性，在写的过程中，原有的读的数据是不会发生更新的，只有新的读才能读到最新数据； 3、如何使其他线程能够及时读到新的数据，需要使用volatile变量； 4、写的时候不能并发写，需要对写操作进行加锁；</p><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210721201347355.png" alt="image-20210721201347355" style="zoom:50%;" /></p><h2 id="源码原理">源码原理</h2><p>写时复制</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*

 *   添加元素api
      */</span>
     <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
     <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">lock</span><span class="o">;</span>
     <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
     <span class="k">try</span> <span class="o">{</span>
         <span class="n">Object</span><span class="o">[]</span> <span class="n">elements</span> <span class="o">=</span> <span class="n">getArray</span><span class="o">();</span>
         <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
         <span class="n">Object</span><span class="o">[]</span> <span class="n">newElements</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">elements</span><span class="o">,</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">//复制一个array副本</span>
         <span class="n">newElements</span><span class="o">[</span><span class="n">len</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span> <span class="c1">//往副本里写入</span>
         <span class="n">setArray</span><span class="o">(</span><span class="n">newElements</span><span class="o">);</span> <span class="c1">//副本替换原本，成为新的原本</span>
         <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
     <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
         <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
     <span class="o">}</span>
     <span class="o">}</span>
     <span class="c1">//读api</span>
     <span class="kd">public</span> <span class="n">E</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">getArray</span><span class="o">(),</span> <span class="n">index</span><span class="o">);</span> <span class="c1">//无锁</span>
     <span class="o">}</span>
</code></pre></div></div><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="http://localhost:4000" target="_blank">WenHao</a></li><li>本文链接：<a href="http://localhost:4000/2020/07/09/Collections%E4%B9%8BMap&List&Set/" target="_blank">http://localhost:4000/2020/07/09/Collections%E4%B9%8BMap&List&Set/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article></div><div class="share"><div class="share-component"></div></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2020/07/09/Collections%E4%B9%8BMap&List&Set/', clientID: '374dc655164bd1e55131', clientSecret: 'cb138e56989989bbb062560782a89bb048c50f58', repo: 'blog-comments', owner: 'wenhaoclub', admin: ['wenhaoclub'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'http://localhost:4000/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2018 <span title="WenHao">WenHao</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="http://github.com/wenhaoclub/wenhaoclub.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="http://localhost:4000/" title="首页" target="">首页</a></li><li> <a href="http://localhost:4000/categories/" title="分类" target="">分类</a></li><li> <a href="http://localhost:4000/archives/" title="归档" target="">归档</a></li><li> <a href="http://localhost:4000/wiki/" title="维基" target="">维基</a></li><li> <a href="http://localhost:4000/links/" title="链接" target="">链接</a></li><li> <a href="http://localhost:4000/about/" title="关于" target="">关于</a></li><li><a href="http://localhost:4000/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2018-05-01 </span></div><script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1279012287'%3E%3C/span%3E%3Cscript src='https://s9.cnzz.com/stat.php%3Fid%3D1279012287%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script> &nbsp &nbsp &nbsp <a href="http://beian.miit.gov.cn" target="_blank">京ICP备2020034168号-1</a> &nbsp &nbsp &nbsp <a href="http://www.beian.gov.cn/portal/registerSystemInfo" target="_blank">京公网安备11010502042362号</a></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
