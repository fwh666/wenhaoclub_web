<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>并发编程(一) 操作系统底层工作的整体认识 &mdash; 文浩</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/primer-markdown/dist/user-content.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="http://localhost:4000/2020/07/01/concurrent-operation/"><link rel="alternate" type="application/atom+xml" title="文浩" href="http://localhost:4000/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/favicon.ico"><meta property="og:title" content="并发编程(一) 操作系统底层工作的整体认识"><meta name="keywords" content="wenhao , 文浩 , 似水似流年 , wenhaoclub , fuwenhao.club , 文浩的博客"><meta name="og:keywords" content="wenhao , 文浩 , 似水似流年 , wenhaoclub , fuwenhao.club , 文浩的博客"><meta name="description" content="并发编程(一) 操作系统底层工作的整体认识："><meta name="og:description" content="并发编程(一) 操作系统底层工作的整体认识："><meta property="og:url" content="http://localhost:4000/2020/07/01/concurrent-operation/"><meta property="og:site_name" content="文浩"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-07-01"> <script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,"script","https://cdn.jsdelivr.net/gh/wenhaoclub/blog-assets/files/js/84f024a1.js","daovoice"); daovoice('init', { app_id: "84f024a1" }); daovoice('update'); </script> <script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="http://localhost:4000/" title="文浩"><span class="octicon octicon-mark-github"></span> 文浩</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="http://localhost:4000/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="http://localhost:4000/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="http://localhost:4000/archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="http://localhost:4000/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="http://localhost:4000/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="http://localhost:4000/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="并发编程(一) 操作系统底层工"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">并发编程(一) 操作系统底层工作的整体认识</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/07/01 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="http://localhost:4000/categories/#并发" title="并发">并发</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 5564 字，约 16 分钟 </span></div></div></div><div class="column one-fourths mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><div><article class="article-content markdown-body"><h1 id="并发编程一-操作系统底层工作的整体认识">并发编程(一) 操作系统底层工作的整体认识：</h1><blockquote><p>可以参考操作系统概论中知识点综合理解。中间会涉及到临界区，CPU操作的三种状态，就绪，运行，等待。</p><p>操作系统概论章节涉及：系统概论简介、进程管理、进程调度和死锁、内存管理、文件系统、I/O设备管理</p><p>熟悉底层CPU、内存、线程之间的调用关系，有助于理解并发。</p></blockquote><h2 id="冯诺依曼计算机模型详解">冯诺依曼计算机模型详解：</h2><p>​ 现代计算机模型是基于-冯诺依曼计算机模型</p><p>​ 计算机在运行时，先从内存中取出第一条指令，通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工，然后再按地址把结果送到内存中去。接下来，再取出第二条指令，在控制器的指挥下完成规定操作。依此进行下去。直至遇到停 止指令。</p><p>​ 程序与数据一样存贮，按程序编排的顺序，一步一步地取出指令，自动地完成指令规定 的操作是计算机最基本的工作模型。这一原理最初是由美籍匈牙利数学家冯.诺依曼于1945 年提出来的，故称为冯.诺依曼计算机模型。</p><h3 id="计算机五大核心组成部分">计算机五大核心组成部分：</h3><ol><li><strong>控制器</strong>(Control):是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。</li><li><strong>运算器</strong>(Datapath):运算器的功能是对数据进行各种算术运算和逻辑运算，即对数据 进行加工处理。</li><li><strong>存储器</strong>(Memory):存储器的功能是存储程序、数据和各种信号、命令等信息，并在 需要时提供这些信息。</li><li><strong>输入</strong>(Input system):输入设备是计算机的重要组成部分，输入设备与输出设备合你 为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现 场采集的数据等信息输入到计算机。常见的输入设备有键盘、鼠标器、光电输入机、磁带 机、磁盘机、光盘机等。</li><li><strong>输出</strong>(Output system):输出设备与输入设备同样是计算机的重要组成部分，它把外 算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来。 微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。</li></ol><p>​</p><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210715111728307.png" alt="冯诺依曼计算机模型" /></p><p>上面的模型是一个理论的抽象简化模型，它的具体应用就是现代计算机当中的硬件结构设计:</p><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210715111909140.png" alt="image-20210715111909140" style="zoom: 50%;" /></p><p>在上图硬件结构当中，配件很多，但最核心的只有两部分:<strong>CPU、内存</strong>。</p><h3 id="cpu指令结构">CPU指令结构</h3><blockquote><p>控制单元、运算单元、数据单元</p></blockquote><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210715112035580.png" alt="CPU指令结构" /></p><h4 id="控制单元">控制单元：</h4><p>​ 控制单元是整个CPU的指挥控制中心，由指令寄存器IR(Instruction Register)、指 令译码器ID(Instruction Decoder)和 操作控制器OC(Operation Controller) 等组 成，对协调整个电脑有序工作极为重要。它根据用户预先编好的程序，依次从存储器中取出 各条指令，放在指令寄存器IR中，通过指令译码(分析)确定应该进行什么操作，然后通过 操作控制器OC，按确定的时序，向相应的部件发出微操作控制信号。操作控制器OC中主要 包括:节拍脉冲发生器、控制矩阵、时钟脉冲发生器、复位电路和启停电路等控制逻辑。</p><h4 id="运算单元">运算单元：</h4><p>​ 运算单元是运算器的核心。可以执行算术运算(包括加减乘数等基本运算及其附加运 算)和逻辑运算(包括移位、逻辑测试或两个值比较)。相对控制单元而言，运算器接受控 制单元的命令而进行动作，即运算单元所进行的全部操作都是由控制单元发出的控制信号来 指挥的，所以它是执行部件。</p><h4 id="存储单元">存储单元：</h4><p>​ 存储单元包括 CPU 片内缓存Cache和寄存器组，是 CPU 中暂时存放数据的地方，里 面保存着那些等待处理的数据，或已经处理过的数据，CPU 访问寄存器所用的时间要比访 问内存的时间短。 寄存器是CPU内部的元件，寄存器拥有非常高的读写速度，所以在寄存 器之间的数据传送非常快。采用寄存器，可以减少 CPU 访问内存的次数，从而提高了 CPU 的工作速度。寄存器组可分为专用寄存器和通用寄存器。专用寄存器的作用是固定的，分别 寄存相应的数据;而通用寄存器用途广泛并可由程序员规定其用途。</p><p>下表列出了CPU关键技术的发展历程以及代表系列，每一个关键技术的诞生都是环环相 扣的，处理器这些技术发展历程都围绕着如何不让“CPU闲下来”这一个核心目标展开。</p><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210715112338658.png" alt="image-20210715112338658" /></p><h3 id="cpu缓存结构">CPU缓存结构：</h3><p>现代CPU为了提升执行效率，减少CPU与内存的交互(交互影响CPU效率)，一般在CPU上集 成了多级缓存架构，常见的为三级缓存结构</p><ul><li>L1 Cache，分为数据缓存和指令缓存，逻辑核独占</li><li>L2 Cache，物理核独占，逻辑核共享</li><li>L3 Cache，所有物理核共享</li></ul><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210715112515972.png" alt="image-20210715112515972" /></p><p>存储器存储空间大小: 内存&gt;L3&gt;L2&gt;L1&gt;寄存器;</p><p>存储器速度快慢排序: 寄存器&gt;L1&gt;L2&gt;L3&gt;内存;</p><p>还有一点值得注意的是:缓存是由最小的存储区块-缓存行(cacheline)组成，缓存行大小通 常为64byte。</p><p><strong>缓存行是什么意思呢?</strong></p><p>​ 比如你的L1缓存大小是512kb,而cacheline = 64byte,那么就是L1里有512 * 1024/64个cacheline</p><h4 id="cpu读取存储器数据过程">CPU读取存储器数据过程</h4><p>1、CPU要取寄存器X的值，只需要一步:直接读取。 2、CPU要取L1 cache的某个值，需要1-3步(或者更多):把cache行锁住，把某个数据拿来，解 锁，如果没锁住就慢了。 3、CPU要取L2 cache的某个值，先要到L1 cache里取，L1当中不存在，在L2里，L2开始加锁，加 锁以后，把L2里的数据复制到L1，再执行读L1的过程，上面的3步，再解锁。 4、CPU取L3 cache的也是一样，只不过先由L3复制到L2，从L2复制到L1，从L1到CPU。 5、CPU取内存则最复杂:通知内存控制器占用总线带宽，通知内存加锁，发起内存读请求，等待 回应，回应数据保存到L3(如果没有就到L2)，再从L3/2到L1，再从L1到CPU，之后解除总线锁 定。</p><h4 id="cpu为何要有高速缓存">CPU为何要有高速缓存</h4><p>CPU在摩尔定律的指导下以每18个月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU。这就造成了高性能能的内存和硬盘价格及其昂贵。然而CPU的高度运算需要高速的数据。为了解决这个问题，CPU厂商在CPU中内置了少量的高速缓存以解决I\O速度和CPU运算速度之间的不匹配问题。</p><p>在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理。</p><p><strong>时间局部性(Temporal Locality):</strong> 如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。 比如循环、递归、方法的反复调用等。 <strong>空间局部性(Spatial Locality):</strong> 如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。 比如顺序执行的代码、连续创建的两个对象、数组等。</p><p>空间局部性原则举例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TwoDimensionalArraySum</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">RUNS</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DIMENSION_1</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DIMENSION_2</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span><span class="o">[][]</span> <span class="n">longs</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="cm">/*
         * 初始化数组
         */</span>
        <span class="n">longs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">DIMENSION_1</span><span class="o">][];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DIMENSION_1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">longs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">DIMENSION_2</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">DIMENSION_2</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">longs</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1L</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Array初始化完毕...."</span><span class="o">);</span>

        <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0L</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">intr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">RUNS</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DIMENSION_1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span><span class="c1">//DIMENSION_1=1024*1024</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">DIMENSION_2</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span><span class="c1">//6</span>
                    <span class="n">sum</span> <span class="o">+=</span> <span class="n">longs</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>带有高速缓存的CPU执行计算的流程：</strong></p><ol><li>程序以及数据被加载到主内存</li><li><p>指令和数据被加载到CPU的高速缓存</p><ol><li>CPU执行指令，把结果写到高速缓存 4. 高速缓存中的数据写回主内存</li></ol></li></ol><h4 id="cpu运行安全等级">CPU运行安全等级</h4><p>CPU有4个运行级别，分别为: ring0 ring1 ring2 ring3</p><p>​ Linux与Windows只用到了2个级别:ring0、ring3，操作系统内部内部程序指令通常运 行在ring0级别，操作系统以外的第三方程序运行在ring3级别，第三方程序如果要调用操作 系统内部函数功能，由于运行安全级别不够,必须切换CPU运行状态，从ring3切换到ring0, 然后执行系统函数，说到这里相信同学们明白为什么JVM创建线程，线程阻塞唤醒是重型操 作了，因为CPU要切换运行状态。</p><p>下面我大概梳理一下<strong>JVM创建线程CPU的工作过程：</strong></p><blockquote><p>step1:CPU从ring3切换ring0创建线程</p><p>step2:创建完毕,CPU从ring0切换回ring3</p><p>step3:线程执行JVM程序</p><p>step4:线程执行完毕，销毁还得切会ring0</p></blockquote><h2 id="操作系统内存管理">操作系统内存管理：</h2><h3 id="执行空间保护">执行空间保护</h3><p>​ 操作系统有用户空间与内核空间两个概念，目的也是为了做到程序运行安全隔离与稳定，以 32位操作系统4G大小的内存空间为例</p><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210715121048476.png" alt="image-20210715121048476" /></p><p>​ Linux为内核代码和数据结构预留了几个页框，这些页永远不会被转出到磁盘上。从 0x00000000 到 0xc0000000(PAGE_OFFSET) 的线性地址可由用户代码 和 内核代码进 行引用(<strong>即用户空间</strong>)。</p><p>​ 从0xc0000000(PAGE_OFFSET)到 0xFFFFFFFFF的线性地址只 能由内核代码进行访问(即<strong>内核空间</strong>)。内核代码及其数据结构都必须位于这 1 GB的地址 空间中，但是对于此地址空间而言，更大的消费者是物理地址的虚拟映射。</p><p>​ 这意味着在 4 GB 的内存空间中，只有 3 GB 可以用于用户应用程序。进程与线程只能 运行在用户方式(usermode)或内核方式(kernelmode)下。用户程序运行在用户方式 下，而系统调用运行在内核方式下。在这两种方式下所用的堆栈不一样:用户方式下用的是 一般的堆栈(用户空间的堆栈)，而内核方式下用的是固定大小的堆栈(内核空间的对战，一 般为一个内存页的大小)，即每个进程与线程其实有两个堆栈，分别运行与用户态与内核 态。</p><p>由空间划分我们再引深一下，CPU调度的基本单位线程，也划分为:</p><blockquote><p>1、内核线程模型(KLT)</p><p>2、用户线程模型(ULT)</p></blockquote><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210715121234242.png" alt="image-20210715121234242" /></p><p>​ 内核线程(KLT):系统内核管理线程(KLT),内核保存线程的状态和上下文信息，线程阻塞不会 引起进程阻塞。在多处理器系统上，多线程在多处理器上并行运行。线程的创建、调度和管 理由内核完成，效率比ULT要慢，比进程操作快。</p><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210715121256718.png" alt="image-20210715121256718" /></p><p>​ 用户线程(ULT):用户程序实现,不依赖操作系统核心,应用提供创建、同步、调度和管理线程 的函数来控制用户线程。不需要用户态/内核态切换，速度快。内核对ULT无感知，线程阻 塞则进程(包括它的所有线程)阻塞。</p><h2 id="进程与线程">进程与线程：</h2><h4 id="概念">概念：</h4><p><strong>什么是进程?</strong></p><p>​ 现代操作系统在运行一个程序时，会为其创建一个进程;例如，启动一个Java程序，操作系统就会创建一个Java进程。进程是OS(操作系统)资源分配的最小单位。</p><p><strong>什么是线程?</strong></p><p>​ 线程是OS(操作系统)调度CPU的最小单元，也叫轻量级进程(Light Weight Process)， 在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性， 并且能够访问共享的内存变量。CPU在这些线程上高速切换，让使用者感觉到这些线程在同 时执行，即并发的概念，相似的概念还有并行!</p><p><img src="https://gitee.com/fwh666/fwh_images/raw/master/fwh_images/image-20210715121411708.png" alt="image-20210715121411708" /></p><h2 id="虚拟机指令集架构">虚拟机指令集架构：</h2><p>虚拟机指令集架构主要分两种: 1、栈指令集架构 2、寄存器指令集架构 关于指令集架构的wiki详细说明: https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B</p><h3 id="栈指令集架构">栈指令集架构</h3><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 设计和实现更简单,适用于资源受限的系统;
 	2. 避开了寄存器的分配难题:使用零地址指令方式分配;
 	3. 指令流中的指令大部分是零地址指令,其执行过程依赖与操作栈,指令集更小,编译器 容易实现;
 	4. 不需要硬件支持,可移植性更好,更好实现跨平台。
</code></pre></div></div><h3 id="寄存器指令集架构">寄存器指令集架构</h3><ol><li>典型的应用是x86的二进制指令集:比如传统的PC以及Android的Davlik虚拟机。</li><li>指令集架构则完全依赖硬件,可移植性差。</li><li>性能优秀和执行更高效。</li><li>花费更少的指令去完成一项操作。</li><li>在大部分情况下,基于寄存器架构的指令集往往都以一地址指令、二地址指令和三 地址指令为主,而基于栈式架构的指令集却是以零地址指令为主。</li></ol><p>Java符合典型的栈指令集架构特征，像Python、Go都属于这种架构。</p><h1 id="总结">总结：</h1><ul><li>将电脑理解成人脑。CPU是最核心思想的地方，内存是临时存储记忆的地方，进程和线程相当于神经脉络，文件存储是长期存储记忆。</li><li>基础流程：CPU从内存获取数据加工运算，在放入内存中，需要长期调用的数据就持久化。</li><li>详细流程：为了快速的获取数据，为了数据更新的一致性问题<ul><li>CPU内部的寄存器从内存获取数据，通过L1，L2,L3级缓存进行高速读取。中间涉及到安全等级和运算速度</li><li>CPU通过总线来统一获取数据和回写数据，保证缓存中数据的一致性，后续涉及到MIES理论。</li></ul></li><li>举例详细：<ul><li>大脑读取短期记忆，快速读取和读取的一致性，神经脑细胞快速传递和神经元分裂传递处理，最终有的数据持久化到长期记忆中。</li><li>CPU、内存、进程、线程、文件系统</li></ul></li></ul><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="http://localhost:4000" target="_blank">WenHao</a></li><li>本文链接：<a href="http://localhost:4000/2020/07/01/concurrent-operation/" target="_blank">http://localhost:4000/2020/07/01/concurrent-operation/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article></div><div class="share"><div class="share-component"></div></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2020/07/01/concurrent-operation/', clientID: '374dc655164bd1e55131', clientSecret: 'cb138e56989989bbb062560782a89bb048c50f58', repo: 'blog-comments', owner: 'wenhaoclub', admin: ['wenhaoclub'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'http://localhost:4000/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2018 <span title="WenHao">WenHao</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="http://github.com/wenhaoclub/wenhaoclub.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="http://localhost:4000/" title="首页" target="">首页</a></li><li> <a href="http://localhost:4000/categories/" title="分类" target="">分类</a></li><li> <a href="http://localhost:4000/archives/" title="归档" target="">归档</a></li><li> <a href="http://localhost:4000/wiki/" title="维基" target="">维基</a></li><li> <a href="http://localhost:4000/links/" title="链接" target="">链接</a></li><li> <a href="http://localhost:4000/about/" title="关于" target="">关于</a></li><li><a href="http://localhost:4000/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2018-05-01 </span></div><script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1279012287'%3E%3C/span%3E%3Cscript src='https://s9.cnzz.com/stat.php%3Fid%3D1279012287%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script> &nbsp &nbsp &nbsp <a href="http://beian.miit.gov.cn" target="_blank">京ICP备2020034168号-1</a> &nbsp &nbsp &nbsp <a href="http://www.beian.gov.cn/portal/registerSystemInfo" target="_blank">京公网安备11010502042362号</a></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
