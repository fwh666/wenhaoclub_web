<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>JVM调优工具详解及调优实战 &mdash; 文浩</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/primer-markdown/dist/user-content.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="http://localhost:4000/2020/06/28/jvm-tools/"><link rel="alternate" type="application/atom+xml" title="文浩" href="http://localhost:4000/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/favicon.ico"><meta property="og:title" content="JVM调优工具详解及调优实战"><meta name="keywords" content="wenhao , 文浩 , 似水似流年 , wenhaoclub , fuwenhao.club , 文浩的博客,jvm,java"><meta name="og:keywords" content="wenhao , 文浩 , 似水似流年 , wenhaoclub , fuwenhao.club , 文浩的博客,jvm,java"><meta name="description" content="序： JVM调优工具详解及调优实战"><meta name="og:description" content="序： JVM调优工具详解及调优实战"><meta property="og:url" content="http://localhost:4000/2020/06/28/jvm-tools/"><meta property="og:site_name" content="文浩"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-06-28"> <script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,"script","https://cdn.jsdelivr.net/gh/wenhaoclub/blog-assets/files/js/84f024a1.js","daovoice"); daovoice('init', { app_id: "84f024a1" }); daovoice('update'); </script> <script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="http://localhost:4000/" title="文浩"><span class="octicon octicon-mark-github"></span> 文浩</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="http://localhost:4000/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="http://localhost:4000/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="http://localhost:4000/archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="http://localhost:4000/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="http://localhost:4000/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="http://localhost:4000/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="JVM调优工具详解及调优实战"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">JVM调优工具详解及调优实战</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/06/28 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="http://localhost:4000/categories/#Jvm" title="Jvm">Jvm</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 7062 字，约 21 分钟 </span></div></div></div><div class="column one-fourths mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><div><article class="article-content markdown-body"><h2 id="序">序：</h2><blockquote><p>JVM调优工具详解及调优实战</p></blockquote><h2 id="前置启动程序">前置启动程序</h2><p>事先启动一个web应用程序，用jps查看其进程id，接着用各种jdk自带命令优化应用</p><h3 id="jmap">Jmap</h3><p>此命令可以用来查看内存信息，实例个数以及占用内存大小</p><p>打开log.txt，文件内容如下：</p><p>num：序号 instances：实例数量 bytes：占用空间大小 class name：类名称，[C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[[I is a int[][]</p><h3 id="堆信息">堆信息</h3><p>堆内存dump jmap -dump:format=b,file=eureka.hprof 14660</p><p>也可以设置内存溢出自动导出dump文件(内存很大的时候，可能会导不出来) -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./ （路径） 示例代码： public class OOMTest {</p><p>public static List<object> list = new ArrayList&lt;&gt;();</object></p><p>// JVM设置 <br /> // -Xms10M -Xmx10M -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\jvm.dump public static void main(String[] args) { List<object> list = new ArrayList&lt;&gt;(); int i = 0; int j = 0; while (true) { list.add(new User(i++, UUID.randomUUID().toString())); new User(j–, UUID.randomUUID().toString()); } } }</object></p><p>可以用jvisualvm命令工具导入该dump文件分析</p><h3 id="jstack">Jstack</h3><p>用jstack加进程id查找死锁，见如下示例 public class DeadLockTest {</p><p>private static Object lock1 = new Object(); private static Object lock2 = new Object();</p><p>public static void main(String[] args) { new Thread(() -&gt; { synchronized (lock1) { try { System.out.println(“thread1 begin”); Thread.sleep(5000); } catch (InterruptedException e) { } synchronized (lock2) { System.out.println(“thread1 end”); } } }).start();</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  new Thread(() -&gt; {
     synchronized (lock2) {
        try {
           System.out.println("thread2 begin");
           Thread.sleep(5000);
        } catch (InterruptedException e) {
        }
        synchronized (lock1) {
           System.out.println("thread2 end");
        }
     }
  }).start();

  System.out.println("main thread end");    } }
</code></pre></div></div><p>“Thread-1” 线程名 prio=5 优先级=5 tid=0x000000001fa9e000 线程id nid=0x2d64 线程对应的本地线程标识nid java.lang.Thread.State: BLOCKED 线程状态</p><p>还可以用jvisualvm自动检测死锁</p><h3 id="远程连接jvisualvm">远程连接jvisualvm</h3><p>启动普通的jar程序JMX端口配置： java -Dcom.sun.management.jmxremote.port=8888 -Djava.rmi.server.hostname=192.168.65.60 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -jar microservice-eureka-server.jar</p><p>PS： -Dcom.sun.management.jmxremote.port 为远程机器的JMX端口 -Djava.rmi.server.hostname 为远程机器IP</p><p>tomcat的JMX配置：在catalina.sh文件里的最后一个JAVA_OPTS的赋值语句下一行增加如下配置行 JAVA_OPTS=”$JAVA_OPTS -Dcom.sun.management.jmxremote.port=8888 -Djava.rmi.server.hostname=192.168.50.60 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false”</p><p>连接时确认下端口是否通畅，可以临时关闭下防火墙 systemctl stop firewalld #临时关闭防火墙</p><h3 id="jstack找出占用cpu最高的线程堆栈信息">jstack找出占用cpu最高的线程堆栈信息</h3><p>package com.tuling.jvm;</p><p>/**</p><ul><li><p>运行此代码，cpu会飙高 */ public class Math {</p><p>public static final int initData = 666; public static User user = new User();</p><p>public int compute() { //一个方法对应一块栈帧内存区域 int a = 1; int b = 2; int c = (a + b) * 10; return c; }</p><p>public static void main(String[] args) { Math math = new Math(); while (true){ math.compute(); } } }</p></li></ul><p>1，使用命令top -p<pid> ，显示你的java进程的内存情况，pid是你的java进程号，比如19663</pid></p><p>2，按H，获取每个线程的内存情况</p><p>3，找到内存和cpu占用最高的线程tid，比如19664 4，转为十六进制得到 0x4cd0，此为线程id的十六进制表示 5，执行 jstack 19663|grep -A 10 4cd0，得到线程堆栈信息中 4cd0 这个线程所在行的后面10行，从堆栈中可以发现导致cpu飙高的调用方法</p><p>6，查看对应的堆栈信息找出可能存在问题的代码</p><h3 id="jinfo">Jinfo</h3><p>查看正在运行的Java应用程序的扩展参数 查看jvm的参数</p><p>查看java系统参数</p><h3 id="jstat">Jstat</h3><p>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下： jstat [-命令选项] [vmid] [间隔时间(毫秒)] [查询次数] 注意：使用的jdk版本是jdk8</p><h3 id="垃圾回收统计">垃圾回收统计</h3><p>jstat -gc pid 最常用，可以评估程序内存使用及GC压力整体情况</p><p>S0C：第一个幸存区的大小，单位KB S1C：第二个幸存区的大小 S0U：第一个幸存区的使用大小 S1U：第二个幸存区的使用大小 EC：伊甸园区的大小 EU：伊甸园区的使用大小 OC：老年代大小 OU：老年代使用大小 MC：方法区大小(元空间) MU：方法区使用大小 CCSC:压缩类空间大小 CCSU:压缩类空间使用大小 YGC：年轻代垃圾回收次数 YGCT：年轻代垃圾回收消耗时间，单位s FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间，单位s GCT：垃圾回收消耗总时间，单位s</p><h3 id="堆内存统计">堆内存统计</h3><p>NGCMN：新生代最小容量 NGCMX：新生代最大容量 NGC：当前新生代容量 S0C：第一个幸存区大小 S1C：第二个幸存区的大小 EC：伊甸园区的大小 OGCMN：老年代最小容量 OGCMX：老年代最大容量 OGC：当前老年代大小 OC:当前老年代大小 MCMN:最小元数据容量 MCMX：最大元数据容量 MC：当前元数据空间大小 CCSMN：最小压缩类空间大小 CCSMX：最大压缩类空间大小 CCSC：当前压缩类空间大小 YGC：年轻代gc次数 FGC：老年代GC次数</p><h3 id="新生代垃圾回收统计">新生代垃圾回收统计</h3><p>S0C：第一个幸存区的大小 S1C：第二个幸存区的大小 S0U：第一个幸存区的使用大小 S1U：第二个幸存区的使用大小 TT:对象在新生代存活的次数 MTT:对象在新生代存活的最大次数 DSS:期望的幸存区大小 EC：伊甸园区的大小 EU：伊甸园区的使用大小 YGC：年轻代垃圾回收次数 YGCT：年轻代垃圾回收消耗时间</p><h3 id="新生代内存统计">新生代内存统计</h3><p>NGCMN：新生代最小容量 NGCMX：新生代最大容量 NGC：当前新生代容量 S0CMX：最大幸存1区大小 S0C：当前幸存1区大小 S1CMX：最大幸存2区大小 S1C：当前幸存2区大小 ECMX：最大伊甸园区大小 EC：当前伊甸园区大小 YGC：年轻代垃圾回收次数 FGC：老年代回收次数</p><h3 id="老年代垃圾回收统计">老年代垃圾回收统计</h3><p>MC：方法区大小 MU：方法区使用大小 CCSC:压缩类空间大小 CCSU:压缩类空间使用大小 OC：老年代大小 OU：老年代使用大小 YGC：年轻代垃圾回收次数 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间</p><h3 id="老年代内存统计">老年代内存统计</h3><p>OGCMN：老年代最小容量 OGCMX：老年代最大容量 OGC：当前老年代大小 OC：老年代大小 YGC：年轻代垃圾回收次数 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间</p><h3 id="元数据空间统计">元数据空间统计</h3><p>MCMN:最小元数据容量 MCMX：最大元数据容量 MC：当前元数据空间大小 CCSMN：最小压缩类空间大小 CCSMX：最大压缩类空间大小 CCSC：当前压缩类空间大小 YGC：年轻代垃圾回收次数 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间</p><p>S0：幸存1区当前使用比例 S1：幸存2区当前使用比例 E：伊甸园区使用比例 O：老年代使用比例 M：元数据区使用比例 CCS：压缩使用比例 YGC：年轻代垃圾回收次数 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间</p><h2 id="jvm运行情况预估">JVM运行情况预估</h2><p>用 jstat gc -pid 命令可以计算出如下一些关键数据，有了这些数据就可以采用之前介绍过的优化思路，先给自己的系统设置一些初始性的JVM参数，比如堆内存大小，年轻代大小，Eden和Survivor的比例，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值等。</p><p>年轻代对象增长的速率 可以执行命令 jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)，通过观察EU(eden区的使用)来估算每秒eden大概新增多少对象，如果系统负载不高，可以把频率1秒换成1分钟，甚至10分钟来观察整体情况。注意，一般系统可能有高峰期和日常期，所以需要在不同的时间分别估算不同情况下对象增长速率。</p><p>Young GC的触发频率和每次耗时 知道年轻代对象增长速率我们就能推根据eden区的大小推算出Young GC大概多久触发一次，Young GC的平均耗时可以通过 YGCT/YGC 公式算出，根据结果我们大概就能知道系统大概多久会因为Young GC的执行而卡顿多久。</p><p>每次Young GC后有多少对象存活和进入老年代 这个因为之前已经大概知道Young GC的频率，假设是每5分钟一次，那么可以执行命令 jstat -gc pid 300000 10 ，观察每次结果eden，survivor和老年代使用的变化情况，在每次gc后eden区使用一般会大幅减少，survivor和老年代都有可能增长，这些增长的对象就是每次Young GC后存活的对象，同时还可以看出每次Young GC后进去老年代大概多少对象，从而可以推算出老年代对象增长速率。</p><p>Full GC的触发频率和每次耗时 知道了老年代对象的增长速率就可以推算出Full GC的触发频率了，Full GC的每次耗时可以用公式 FGCT/FGC 计算得出。</p><p>优化思路其实简单来说就是尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。</p><h3 id="系统频繁full-gc导致系统卡顿是怎么回事">系统频繁Full GC导致系统卡顿是怎么回事</h3><p>机器配置：2核4G JVM内存大小：2G 系统运行时间：7天 期间发生的Full GC次数和耗时：500多次，200多秒 期间发生的Young GC次数和耗时：1万多次，500多秒</p><p>大致算下来每天会发生70多次Full GC，平均每小时3次，每次Full GC在400毫秒左右； 每天会发生1000多次Young GC，每分钟会发生1次，每次Young GC在50毫秒左右。</p><p>JVM参数设置如下： -Xms1536M -Xmx1536M -Xmn512M -Xss256K -XX:SurvivorRatio=6 -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly</p><p>大家可以结合对象挪动到老年代那些规则推理下我们这个程序可能存在的一些问题 经过分析感觉可能会由于对象动态年龄判断机制导致full gc较为频繁</p><p>为了给大家看效果，我模拟了一个示例程序(见课程对应工程代码：jvm-full-gc)，打印了jstat的结果如下： jstat -gc 13456 2000 10000</p><p>对于对象动态年龄判断机制导致的full gc较为频繁可以先试着优化下JVM参数，把年轻代适当调大点： -Xms1536M -Xmx1536M -Xmn1024M -Xss256K -XX:SurvivorRatio=6 -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=92 -XX:+UseCMSInitiatingOccupancyOnly</p><p>优化完发现没什么变化，full gc的次数比minor gc的次数还多了</p><p>我们可以推测下full gc比minor gc还多的原因有哪些？ 1、元空间不够导致的多余full gc 2、显示调用System.gc()造成多余的full gc，这种一般线上尽量通过-XX:+DisableExplicitGC参数禁用，如果加上了这个JVM启动参数，那么代码中调用System.gc()没有任何效果 3、老年代空间分配担保机制</p><p>最快速度分析完这些我们推测的原因以及优化后，我们发现young gc和full gc依然很频繁了，而且看到有大量的对象频繁的被挪动到老年代，这种情况我们可以借助jmap命令大概看下是什么对象</p><p>查到了有大量User对象产生，这个可能是问题所在，但不确定，还必须找到对应的代码确认，如何去找对应的代码了？ 1、代码里全文搜索生成User对象的地方(适合只有少数几处地方的情况) 2、如果生成User对象的地方太多，无法定位具体代码，我们可以同时分析下占用cpu较高的线程，一般有大量对象不断产生，对应的方法代码肯定会被频繁调用，占用的cpu必然较高 可以用上面讲过的jstack或jvisualvm来定位cpu使用较高的代码，最终定位到的代码如下： import java.util.ArrayList;</p><p>@RestController public class IndexController {</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@RequestMapping("/user/process")
public String processUserData() throws InterruptedException {
    ArrayList&lt;User&gt; users = queryUsers();

    for (User user: users) {
        //TODO 业务处理
        System.out.println("user:" + user.toString());
    }
    return "end";
}

/**
 * 模拟批量查询用户场景
 * @return
 */
private ArrayList&lt;User&gt; queryUsers() {
    ArrayList&lt;User&gt; users = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; 5000; i++) {
        users.add(new User(i,"zhuge"));
    }
    return users;
} }
</code></pre></div></div><p>同时，java的代码也是需要优化的，一次查询出500M的对象出来，明显不合适，要根据之前说的各种原则尽量优化到合适的值，尽量消除这种朝生夕死的对象导致的full gc</p><h3 id="内存泄露到底是怎么回事">内存泄露到底是怎么回事</h3><p>再给大家讲一种情况，一般电商架构可能会使用多级缓存架构，就是redis加上JVM级缓存，大多数同学可能为了图方便对于JVM级缓存就简单使用一个hashmap，于是不断往里面放缓存数据，但是很少考虑这个map的容量问题，结果这个缓存map越来越大，一直占用着老年代的很多空间，时间长了就会导致full gc非常频繁，这就是一种内存泄漏，对于一些老旧数据没有及时清理导致一直占用着宝贵的内存资源，时间长了除了导致full gc，还有可能导致OOM。 这种情况完全可以考虑采用一些成熟的JVM级缓存框架来解决，比如ehcache等自带一些LRU数据淘汰算法的框架来作为JVM级的缓存。</p><ul><li><a href="https://cdn.jsdelivr.net/gh/wenhaoclub/blog-assets/files/java/jvm/07-VIP-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98.pdf" target="_blank">完整版链接</a></li></ul><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="http://localhost:4000" target="_blank">WenHao</a></li><li>本文链接：<a href="http://localhost:4000/2020/06/28/jvm-tools/" target="_blank">http://localhost:4000/2020/06/28/jvm-tools/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article></div><div class="share"><div class="share-component"></div></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2020/06/28/jvm-tools/', clientID: '374dc655164bd1e55131', clientSecret: 'cb138e56989989bbb062560782a89bb048c50f58', repo: 'blog-comments', owner: 'wenhaoclub', admin: ['wenhaoclub'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'http://localhost:4000/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2018 <span title="WenHao">WenHao</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="http://github.com/wenhaoclub/wenhaoclub.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="http://localhost:4000/" title="首页" target="">首页</a></li><li> <a href="http://localhost:4000/categories/" title="分类" target="">分类</a></li><li> <a href="http://localhost:4000/archives/" title="归档" target="">归档</a></li><li> <a href="http://localhost:4000/wiki/" title="维基" target="">维基</a></li><li> <a href="http://localhost:4000/links/" title="链接" target="">链接</a></li><li> <a href="http://localhost:4000/about/" title="关于" target="">关于</a></li><li><a href="http://localhost:4000/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2018-05-01 </span></div><script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1279012287'%3E%3C/span%3E%3Cscript src='https://s9.cnzz.com/stat.php%3Fid%3D1279012287%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script> &nbsp &nbsp &nbsp <a href="http://beian.miit.gov.cn" target="_blank">京ICP备2020034168号-1</a> &nbsp &nbsp &nbsp <a href="http://www.beian.gov.cn/portal/registerSystemInfo" target="_blank">京公网安备11010502042362号</a></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/wenhaoclub/wenhaoclub.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
